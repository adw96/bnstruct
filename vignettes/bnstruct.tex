\documentclass{article}
% \VignetteIndexEntry{R package for Bayesian Network Structure Learning}
% \VignettePackage{bnstruct}
% \VignetteKeywords{Documentation}
\usepackage{url}
\usepackage[numbers]{natbib}\citeindextrue

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\usepackage{Sweave}
\begin{document}
\input{bnstruct-concordance}

\title{R package for Bayesian Network Structure Learning}
\author{Francesco Sambo, Alberto Franzin}
\maketitle


\section{Introduction}
Bayesian Networks are a powerful tool for probabilistic inference among a set
of variables, modeled using a directed acyclic graph. However, one often does not
have the network, but only a set of observations, and wants to reconstruct the
network that generated the data. The \Rpackage{bnstruct} package provides objects and methods for
learning the structure and parameters of the network in various situations, such as
in presence of missing data, for which it is possible to perform \textit{imputation}
(guessing the missing values, by looking at the data). The package also contains methods
for learning using the Bootstrap technique.
Finally, \Rpackage{bnstruct}, has a set of additional tools to use Bayesian Networks, such as methods to perform
belief propagation.

This document is intended to show some examples of how \Rpackage{bnstruct} can be used
to learn and use Bayesian Networks. First we describe how to manage data sets,
how to use them to discover a Bayesian Network, and finally how to perform some
operations on a network. Complete reference for classes and methods can be found in the package documentation.

\subsection{Overview}
We provide here some general informations about the context for understanding
and using properly this document.

\subsubsection{The data}
A \emph{dataset} is a collection of rows, each of which is composed by the same number
of values. Each value corresponds to an observation of a \emph{variable}, which is a feature,
an event or an entity considered significant and therefore measured. In a Bayesian Network,
each variable is associated to a node. The number of variables is the \emph{size} of the
network. Each variable has a certain range of values it can take. If the variable can take
any possible value in its range, it is called a \emph{continuous} variable; otherwise,
if a variable can only take some values in its range, it is a \emph{discrete} variable.
The number of values a variable can take is called its \emph{cardinality}.
A continuous variable has infinite cardinality; however, in order to deal with it,
we have to restrict its domain to a smaller set of values, in order to be able to
treat it as a discrete variable; this process is called \emph{quantization}, the
number of values it can take is called the number of \emph{levels} of the quantization step,
and we will therefore call the cardinality of a continuous variable the number of its
quantization levels, with a little abuse of terminology.

In many real-life applications and contexts, it often happens that some observations in
the dataset we are studying are absent, for many reasons. In this case, one may want to
``guess'' a reasonable (according to the other observations) value that would have been
present in the dataset, if the observations was successful. This inference task is
called \emph{imputation}. In this case, the dataset with the ``holes filled''
is called the \emph{imputed dataset}, while the original dataset with missing values is
referred to as the \emph{raw dataset}.
In section \ref{sec:imputation} we show how to perform imputation in \Rpackage{bnstruct}.

Another common operation on data is the employment of resampling techniques in order
to estimate properties of a distribution from an approximate one. This usually allows
to have more confidence in the results. We implement the \emph{bootstrap} technique,
and provide it to generate samples of a dataset, with the chance of using it on both raw and imputed data.

\subsubsection{Bayesian Networks}
After introducing the data, we are now ready to talk about \emph{Bayesian Networks}. A Bayesian Network
(hereafter sometimes simply \emph{network}, \emph{net} or \emph{BN} for brevity) is a probabilistic graphical model that encodes
the conditional dependency relationships of a set of variables using a Directed Acyclic Graph (DAG).
Each node of the graph represents one variable of the dataset; we will therefore interchange
the terms \emph{node} and \emph{variable} when no confusion arises. The set of directed edges
connecting the nodes forms the \emph{structure} of the network, while the set of conditional
probabilities associated with each variable forms the set of \emph{parameters} of the net.

The problems of learning the structure and the parameters of a network from data define the
\emph{structure learning} and \emph{parameter learning} tasks, respectively. 



\section{Installation}

The latest version of \Rpackage{bnstruct} can be found at \url{http://github.com/sambofra/bnstruct}.

In order to install the package, it suffices to launch\\
\verb!R CMD INSTALL path/to/bnstruct!\\
from a terminal, or to use R command \verb!install.packages!.

Being hosted on GitHub, it is also possible to use Hadley Wickham's \texttt{install\_github} tool from
an R session:
\begin{Schunk}
\begin{Sinput}
> library("devtools")
> install_github("sambofra/bnstruct")
\end{Sinput}
\end{Schunk}

For Windows platforms, a binary executable will be provided.

\Rpackage{bnstruct} requires R $\geq 2.10$,
and depends on \Rpackage{bitops}, \Rpackage{igraph}, \Rpackage{Matrix} and \Rpackage{methods}.
Package \Rpackage{Rgraphviz} is requested in order to plot graphs, but it is not mandatory.


\section{Data sets}
The class that \Rpackage{bnstruct} provides to manage datasets is \Robject{BNDataset}.
It contains all of the data and the informations related to it: raw and imputed data, raw and imputed
bootstrap samples, and variable names and cardinality.

\begin{Schunk}
\begin{Sinput}
> dataset <- BNDataset(name="Example")
> # creates an empty BNDataset object
\end{Sinput}
\end{Schunk}


\subsection{Data format}
\Rpackage{bnstruct} requires the data files to be in a format we describe in this section. 
The actual data has to be in (a text file containing data in) tabular format, one tuple per row,
with the values for each variable separated by a space or a tab. Values for each variable have to be
numbers, starting from \texttt{0} in case of discrete variables.
Data files can have a first row containing the names of the corresponding variables.

In addition to the data file, a header file containing additional informations can also be provided.
An header file has to be composed by three rows of tab-delimited values:
\begin{enumerate}
\item list of names of the variables, in the same order of the data file;
\item a list of integers representing the cardinality of the variables, in case of discrete variables,
      or the number of levels each variable has to be quantized in, in case of continuous variables;
\item a list that indicates, for each variable, if the variable is continuous (\texttt{c} or \texttt{C}), and thus has to be quantized before learning,
 or discrete (\texttt{d} or \texttt{D}).
\end{enumerate}

We provide two sample datasets, one with complete data (the \texttt{Asia} network) and one with missing values
(the \texttt{Child} network), in the \texttt{extdata} subfolder;
the user can refer to them as an example.

\subsection{Importing a dataset}
The preferred way to create a \Rclass{BNDataset} object is by reading a dataset from a file.
In order to accomplish this, we provide the \Rmethod{read.dataset} method.

\begin{Schunk}
\begin{Sinput}
> dataset <- BNDataset(name="Example")
> dataset <- read.dataset(dataset,
+                         header.file = "path/to/file.header",
+                         data.file   = "path/to/file.data")
\end{Sinput}
\end{Schunk}

The sample datasets we provide come with two custom loaders:
\begin{Schunk}
\begin{Sinput}
> asia.data  <- asia()
> child.data <- child()
\end{Sinput}
\end{Schunk}

\subsection{Creating a \Robject{BNDataset} from data}
Another possible way for creating a \Robject{BNDataset} is to create it from a \Rclass{data.frame} or a \Rclass{matrix}
and some metadata. This is useful, for example, for instantiating a dataset after the data has already been 
processed in some way.

In particular, it is requested to provide the data, in \texttt{data.frame} or \texttt{matrix} form, and three additional
vectors of informations on the domain: one containing the names of the variables, another one containing values indicating
the cardinality (for discrete variables) or the quantization domain (for continuous variables) of the variables,
and the last one containing the status of the variables (\texttt{c} for continuous, \texttt{d} for discrete). Please note that
all of the metadata are required when choosing this option, and it is also suggested that the slot names
are specified when passing data and metadata as parameters to the constructor;
when no dataset name is provided, the slot names are mandatory.

\begin{Schunk}
\begin{Sinput}
> my.data <- matrix(c(1:16), nrow = 4, ncol = 4)
> my.dataset <- BNDataset(name = "MyData", data = my.data,
+                         variables = c("a", "b", "c", "d"),
+                         node.sizes = c(4,8,12,16),
+                         discreteness = rep('d',4))
\end{Sinput}
\end{Schunk}

\subsection{Imputation}\label{sec:imputation}
A dataset may contain various kinds of missing data, namely unobserved variables,
and unobserved values for otherwise observed variables. We currently deal only with this
second kind of missing data. The process of guessing the missing values is called \emph{imputation}.

We provide the \Rmethod{impute} function to perform imputation.
\begin{Schunk}
\begin{Sinput}
> dataset <- BNDataset(name="Example")
> dataset <- read.dataset(dataset,
+                         header.file = "path/to/file.header",
+                         data.file   = "path/to/file.data")
> dataset <- impute(dataset)
\end{Sinput}
\end{Schunk}

Imputation is accomplished with the k-Nearest Neighbour algorithm. The number of neighbours to be used
can be chosen specifying the \Rfunarg{k.impute} parameter.
Imputation can also be performed during the loading of a dataset, as shown in the following example.
\begin{Schunk}
\begin{Sinput}
> dataset <- BNDataset(name="Example")
> dataset <- read.dataset(dataset,
+                         header.file = "path/to/file.header",
+                         data.file   = "path/to/file.data",
+                         imputation  = TRUE,
+                         k.impute    = 10)
\end{Sinput}
\end{Schunk}

Note that, when imputed data is present, it has higher priority over raw data when using a dataset
(see section \ref{sec:usingdata}).

The sample dataset available using the \Rmethod{child()} method contains both raw and imputed data.

\subsection{Bootstrap}
\Robject{BNDataset} objects have also room for bootstrap samples, i.e. random samples with replacement of the original data with the same number of observations, both for raw and imputed data.
We provide the \Rmethod{bootstrap} method for this.
\begin{Schunk}
\begin{Sinput}
> dataset <- BNDataset(name="Example")
> dataset <- read.dataset(dataset,
+                         header.file = "path/to/file.header",
+                         data.file   = "path/to/file.data")
> dataset <- bootstrap(dataset, num.boots = 100)
> dataset.with.imputed.samples <- bootstrap(dataset,
+                             num.boots = 100, imputation = TRUE)
\end{Sinput}
\end{Schunk}

Again, the generation of bootstrap samples can be performed while loading a dataset.
\begin{Schunk}
\begin{Sinput}
> dataset <- BNDataset(name="Example")
> dataset <- read.dataset(dataset,
+                         header.file = "path/to/file.header",
+                         data.file   = "path/to/file.data",
+                         bootstrap   = TRUE,
+                         num.boots   = 100,
+                         imputation  = TRUE)
\end{Sinput}
\end{Schunk}

The sample datasets provided have no bootstrap samples in them.

\subsection{Using data}
\label{sec:usingdata}
After a \Robject{BNDataset} has been created, it is ready to be used.
The complete list of methods available for a \Robject{BNDataset} object is available
in the package documentation; we are not going to cover all of the methods in this brief series
of examples, but we just show how to retrieve data.

The main operation that can be done with a \Robject{BNDataset} is to get the data it contains.
The main methods we provide are \Rmethod{get.raw.data}, \Rmethod{get.imputed.data} and \Rmethod{get.data}. \Rmethod{get.data} is just a proxy
for one of the other two methods.
As previously mentioned, imputed data (if present) has higher priority over raw data, since it is supposed to be more useful.
Therefore, if imputed data is present, \Rmethod{get.data} will behave as \Rmethod{get.imputed.data}; otherwise,
it will return the raw dataset just like \Rmethod{get.raw.data}.

\begin{Schunk}
\begin{Sinput}
> dataset.1 <- child()
> # if we want raw data
> get.raw.data(dataset.1)
> # if we want imputed dataset, the following are equivalent
> get.imputed.data(dataset.1)
> get.data(dataset.1)
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> dataset.2 <- asia()
> # we can only get raw data, the following are equivalent
> get.raw.data(dataset.2)
> get.data(dataset.2)
\end{Sinput}
\end{Schunk}

We can check if a dataset has imputed data or not with the \Rmethod{has.imputed.data} method.
\begin{Schunk}
\begin{Sinput}
> dataset.1 <- child()
> has.imputed.data(dataset.1) # TRUE
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> dataset.2 <- asia()
> has.imputed.data(dataset.2) # FALSE
\end{Sinput}
\end{Schunk}

In order to retrieve bootstrap samples, one can use the \Rmethod{boots} and \Rmethod{imp.boots} methods for samples
made of raw and imputed data. The presence of imputed samples can be tested using \Rmethod{has.imp.boots}.
We also provide the \Rmethod{get.boot} method to directly access a single sample. Again, imputed samples have higher priority.
\begin{Schunk}
\begin{Sinput}
> # get imputed samples
> for (i in 1:num.boots(dataset))
+   print( get.boot(dataset, i) )
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> # get raw samples
> for (i in 1:num.boots(dataset))
+   print( get.boot(dataset, i, imputed = FALSE) )
\end{Sinput}
\end{Schunk}


\section{Bayesian Networks}
Bayesian Network are represented using the \Robject{BN} object. It contains information regarding the variables in the network,
the directed acyclic graph (DAG) representing the structure of the network, the conditional probability tables entailed by 
the network, and the weighted partially DAG representing the structure as learnt using bootstrap samples.

\begin{Schunk}
\begin{Sinput}
> net <- BN(name = "Example")
\end{Sinput}
\end{Schunk}


The method of choice to create a \Robject{BN} object is to create it from a \Robject{BNDataset}.
The following code will create an empty \Robject{BN} object for the \texttt{Child} network.
\begin{Schunk}
\begin{Sinput}
> dataset <- child() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
\end{Sinput}
\end{Schunk}

% Note that the above snippet already creates a full object, that is, a network with structure and parameters.
% To better highlight the various options and possible operations, we delve a little into the details
% of the main learning methods.

Now, starting from the empty network and the dataset, we can proceed with the tasks of structure and parameter learning.

\subsection{Structure learning}\label{sec:structurelearning}
When constructing a network starting from a dataset, the first operation we may want to perform is to learn
the structure of the network. \Rpackage{bnstruct} provides the \Rmethod{learn.structure} method for this task.
\begin{Schunk}
\begin{Sinput}
> dataset <- child() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> net     <- learn.structure(net, dataset)
\end{Sinput}
\end{Schunk}

The \Rmethod{learn.structure} method returns a new \Robject{BN} object, with a new DAG (or WPDAG, if the structure
learning has been performed using bootstrap -- more on this later).

We provide two algorithms in order to learn the structure of the network, that can be chosen with the \texttt{algo} parameter.
The first is the Silander-Myllym\"aki (\texttt{sm})
exact search-and-score algorithm (see \citet*{silander2012simple}), that performs a complete evaluation of the search space in order to discover
the best network; this algorithm may take a very long time, and can be inapplicable when discovering networks
with more than 25--30 nodes. Even for small networks, users are strongly encouraged to provide
meaningful parameters such as the layering of the nodes, or the maximum number of parents -- refer to the 
documentation in package manual for more details on the method parameters.

The second algorithm (and the default one) is the Max-Min Hill-Climbing heuristic (\texttt{mmhc}, see \citet*{tsamardinos2006max}), that performs a statistical
sieving of the search space followed by a greedy evaluation. It is considerably faster than the complete method, at the cost of a (likely)
lower quality. Also note that in the case of a very dense network and lots of obsevations, the statistical evaluation
of the search space may take a long time. Also for this algorithm there are parameters that may need to be tuned,
mainly the confidence threshold of the statistical pruning.

Search-and-score methods also need a scoring function to compute an estimated measure of each configuration of nodes.
We provide three of the most popular scoring functions, \texttt{BDeu} (Bayesian-Dirichlet equivalent uniform, default),
\texttt{AIC} (Akaike Information Criterion) and \texttt{BIC} (Bayesian Information Criterion). The scoring function
can be chosen using the \texttt{scoring.func} parameter.

\begin{Schunk}
\begin{Sinput}
> dataset <- child() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> net.1   <- learn.structure(net, dataset,
+                            algo = "sm", scoring.func = "AIC")
> net.2   <- learn.structure(net, dataset,
+                            algo = "mmhc", scoring.func = "BDeu")
\end{Sinput}
\end{Schunk}

% Since building a \Robject{BN} object from a \Robject{BNDataset} already performs a structure learning task,
% we can specify the parameters of the \Rmethod{learn.structure} method in the \Rmethod{BN} constructor.
% # <<structurelearn3, eval=FALSE>>=
% # dataset <- child() # or any other way to create a custom BNDataset
% # net     <- BN(dataset, algo = "sm", scoring.func = "AIC")
% # @

The \Rmethod{learn.structure} method by default computes the structure as a DAG. We can however use
bootstrap samples to learn a weighted partially DAG, in order to get a weighted confidence on the presence or
absence of an edge in the structure (\citet*{friedman1999data}). This can be done by providing the constructor or the \Rmethod{learn.structure}
method a \Robject{BNDataset} with bootstrap samples, and the additional parameter \Rfunarg{bootstrap = TRUE}.
\begin{Schunk}
\begin{Sinput}
> dataset <- asia() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> net.1   <- learn.structure(net, dataset, algo = "mmhc",
+               scoring.func = "AIC", bootstrap = TRUE)
> # or, for explicitely learning from raw data
> net.2   <- learn.structure(net, dataset, algo = "mmhc",
+               scoring.func = "AIC", bootstrap = TRUE,
+               imputation = FALSE)
\end{Sinput}
\end{Schunk}

\subsection{Parameter learning}
Parameter learning is the operation that learns the conditional probabilities entailed by a network,
given the data and the structure of the network. \Rpackage{bnstruct} provides the \Rmethod{learn.params} method for this task,
performing a Maximum-A-Posteriori (MAP) estimate of the parameters.
% Also, parameter learning is already performed by the constructor when fed with a \Robject{BNDataset}, and optional
% parameters for \Rmethod{learn.params} such as \Rfunarg{ess} can be passed also to the network constructor.
\begin{Schunk}
\begin{Sinput}
> dataset <- asia() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> net     <- learn.structure(net, dataset, 
+                            algo = "mmhc",
+                            scoring.func = "AIC")
> net     <- learn.params(net, dataset)
\end{Sinput}
\end{Schunk}

\subsection{Reading a network from a file}
Other than starting from a dataset, it is also possible to read a network from a file, formatted in a specific way
in order to describe the structure and the parameters of the network. Several of such formats exist; we provide methods
for two of the most widely adopted ones, the \texttt{dsc} and the \texttt{bif} format. The method names are, respectively,
\Rmethod{read.dsc} and \Rmethod{read.bif}. These methods return a full \Robject{BN} object.

\begin{Schunk}
\begin{Sinput}
> net <- read.dsc("path/to/network.dsc")
> plot(net)
\end{Sinput}
\end{Schunk}


\section{Using a network}
Once a network is created, it can be used. Here we briefly mention some of the basic methods provided in order to
manipulate a network and access its components.

First of all, it is surely of interest to obtain the structure of a network. The \Rpackage{bnstruct} package
provides the \Rmethod{dag()} and \Rmethod{wpdag()} methods in order to access the structure of a network learnt without and
with bootstrap (respectively).
\begin{Schunk}
\begin{Sinput}
> dag(net)
> wpdag(net.boot)
\end{Sinput}
\end{Schunk}

Then we may want to retrieve the parameters, using the \Rmethod{cpts()} method.
\begin{Schunk}
\begin{Sinput}
> cpts(net)
\end{Sinput}
\end{Schunk}

Another common operation that we may want to perform is displaying the network, or printing its main informations, using the
\Rmethod{plot()}, \Rmethod{print()} and \Rmethod{show()} methods. Note that the \Rmethod{plot()} method is flexible enough to allow 
some custom settings such as the choice of the colors of the nodes, and, more importantly, some threshold settings 
for the networks learnt with bootstrap. As default, the DAG of a network is selected for plotting, if available,
otherwise the WPDAG is used. In case of presence of both the DAG and the WPDAG, in order to specify the latter as
structure to be plotted, the \Rfunarg{plot.wpdag} logical parameter is provided.
\begin{Schunk}
\begin{Sinput}
> print(net)
> plot(net) # regular DAG
> plot(net, plot.wpdag=T) # wpdag
> plot(net.boot)
\end{Sinput}
\end{Schunk}

The \Rmethod{show()} method is an alias for the \Rmethod{print()} method, but allows to print the state of an instance of an object
just by typing its name in an \texttt{R} session.
\begin{Schunk}
\begin{Sinput}
> # TFAE
> print(net)
> show(net)
> net
\end{Sinput}
\end{Schunk}


\section{Inference in networks}
\subsection{Belief Propagation}
The \Rpackage{bnstruct} package provides a tool to perform belief propagation using a junction tree.
This tool is the \Robject{InferenceEngine} object.
It contains a copy of a network, an updated network, the adjacency matrix of the junction tree computed
starting from the original network, the list of cliques of variables that form the nodes of the junction tree
and the list of joint probability tables for the cliques composing the junction tree.

An \Robject{InferenceEngine} can be built from a network: in this case, the junction tree is immediately constructed.
%Alternatively, one can use the \Rmethod{build.junction.tree} method.
\begin{Schunk}
\begin{Sinput}
> dataset <- asia() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> inf.eng <- InferenceEngine(net)
\end{Sinput}
\end{Schunk}
% # equivalent to
% inf.eng <- InferenceEnfine()
% bn(inf.eng) <- net
% build.junction.tree(inf.eng, dag(net))
% @

Belief propagation over the junction tree can be then performed using the \Rmethod{belief.propagation} method.
\begin{Schunk}
\begin{Sinput}
> dataset <- asia() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> inf.eng <- InferenceEngine(net)
> inf.eng <- belief.propagation(inf.eng)
\end{Sinput}
\end{Schunk}

Belief propagation can be fed with a list of observations. This can be done in two ways: as parameters in the method,
or inserting them directly into the inference engine. Note that the two options are mutually exclusive, in the sense that
the list of observations given as parameter replaces (in the whole \Robject{InferenceEngine} object returned)
the observations contained in the engine. Furthermore, if a list of observations contains multiple observations
of the same variable, only the last one is considered.
\begin{Schunk}
\begin{Sinput}
> dataset <- asia() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> net     <- learn.structure(net, dataset)
> net     <- learn.params(net, dataset)
> inf.eng <- InferenceEngine(net)
> inf.eng <- belief.propagation(inf.eng,
+                               observed.vars = c("Asia","X-ray"),
+                               observed.vals = c(1,1))
> print(updated.bn(inf.eng))
> # is equivalent to
> observations(inf.eng) <- list(c("Asia","X-ray"), c(1,1))
> inf.eng <- belief.propagation(inf.eng)
> plot(updated.bn(inf.eng))
\end{Sinput}
\end{Schunk}

\subsection{The Expectation-Maximization algorithm}
Package \Rpackage{bnstruct} can also use an \Robject{InferenceEngine} and a \Robject{BNDataset} to perform
the Expectation-Maximization algorithm to estimate the parameters of the network.
It suffices to use the \Rmethod{em} method, that returns an \Robject{InferenceEngine} containing
an updated network with the newly estimated conditional probability tables.

It is possible to control the algorithm by specifying the \Rfunarg{threshold} parameter, that specifies a threshold
for the convergence of the algorithm.
\begin{Schunk}
\begin{Sinput}
> dataset <- child() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> net     <- learn.structure(net, dataset)
> net     <- learn.params(net, dataset)
> inf.eng <- InferenceEngine(net)
> inf.eng <- em(inf.eng, dataset)
> print(updated.bn(inf.eng))
\end{Sinput}
\end{Schunk}

\subsection{The Structural EM algorithm}
We provide an implementation of the Structural Expectation-Maximization algorithm
(\citet{friedman1997learning,friedman1998bayesian}),
in order to learn both the structure and the parameters of a network in case of a dataset containing missing values.
The method provided is \Rmethod{sem}. It accepts as parameters an \Robject{InferenceEngine} and a \Robject{BNDataset}.
Also this method can be controlled with thresholds for the structure learning and the parameter learning steps, namely
\Rfunarg{struct.threshold} and \Rfunarg{param.threshold}.

The method accepts also all of the parameters available for the structure learning method (see section \ref{sec:structurelearning}).
However, the method is designed in order to follow as much as possible the settings of the original learning, whenever possible.
For example, it is strongly recommended to adopt the same scoring function used in the learning of the network structure.
If the network has been first learnt using \Rpackage{bnstruct}, the method will take care of that;
in case of network read from a file, this is left to the user.

\begin{Schunk}
\begin{Sinput}
> dataset <- child() # or any other way to create a custom BNDataset
> net     <- BN(dataset)
> net     <- learn.structure(net, dataset)
> net     <- learn.params(net, dataset)
> inf.eng <- InferenceEngine(net)
> inf.eng <- sem(inf.eng, dataset)
> plot(updated.bn(inf.eng))
\end{Sinput}
\end{Schunk}


\section{Other utilities}
\subsection{Sample data}
We provide also methods for generating a sample of data, or a complete dataset.

The two methods for this purpose are the \Rmethod{sample.row} and \Rmethod{sample.dataset}, that generate, respectively,
a vector of values and a \Robject{BNDataset} object. Both the methods accept as first argument a \Robject{BN} or an
\Robject{InferenceEngine} object. To generate a \Robject{BNDataset} with \Rmethod{sample.dataset} one should also provide the
number of observations to sample, via the \Rfunarg{n} parameter.

\begin{Schunk}
\begin{Sinput}
> net <- BN(...)
> eng <- InferenceEngine(net)
> sample.row(net)
> sample.row(eng)
> sample.dataset(net,1000)
> sample.dataset(eng,10000)
\end{Sinput}
\end{Schunk}


\bibliographystyle{plainnat}
\bibliography{bibtex}

\end{document}
